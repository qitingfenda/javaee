堆的核心概述
 - 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
 - Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
   - 堆内存的大小是可以调节的。
 - 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
 - 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer, TLAB)。
 - 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。
   (The heap is the run-time data area from which memory for all class instances and arrays is allocated )
    - "几乎"所有的对象实例都在这里分配内存。————从实际使用角度看的。
 - 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
 - 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
 - 堆，是GC ( Garbage Collection， 垃圾收集器)执行垃圾回收的重点区域。

内存细分：现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为:
Java 7及之前堆内存逻辑。上分为三部分:新生区+养老区+永久区
 - Young Generation Space           新生区     Young/New
   又被划分为Eden区和Survivor区
 - Tenure generation space          养老区     old/Tenure
 - Permanent Space                  永久区     Perm

Java 8及之后堆内存逻辑。上分为三部分:新生区+养老区+元空间
 - Young Generation Space           新生区     Young/New
   又被划分为Eden区和Survivor区
 - Tenure generation space          养老区     old/Tenure
 - Meta Space                       元空间     Meta

约定：新生区=新生代=年轻代、养老区=老年区=老年代、永久区=永久代

堆空间大小的设置：
 - Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项"-Xmx"和"-Xms"来进行设置。
    -"Xms" 用于表示堆区的起始内存，等价于-XX:InitialHeapSize
    -"Xmx" 则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
 - 一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会抛出 OutOfMemoryError异常。
 - 通常会将-Xms 和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
 - 默认情况下，初始内存大小:物理电脑内存大小/64，最大内存大小:物理电脑内存大小/4

年轻代与老年代
存储在JVM中的Java对象可以被划分为两类:
 - 类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
 - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持-致。
Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(oldGen)
其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区)。

配置新生代与老年代在堆结构的占比
 - 默认-Xx:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
 - 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5

在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
当然开发人员可以通过选项"-XX:SurvivorRatio"调整这个空间比例。比如-XX:SurvivorRatio=8
几乎所有的Java对象都是在Eden区被new出来的。
绝大部分的Java对象的销毁都在新生代进行了。
 - IBM公司的专门研究表明，新生代中80%的对象都是"朝生夕死"的。
可以使用选项"-Xmn"设置新生代最大内存大小.
 - 这个参数一般使用默认值就可以了。

对象分配过程：概述
为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，
并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。
1. new的对象先放伊甸园区。此区有大小限制。
2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，
  将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3.然后将伊甸园中的剩余对象移动到幸存者0区。
4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6.啥时候能去养老区呢?可以设置次数。默认是15次。
  可以设置参数: -XX:MaxTenuringThreshold=<N>进行设置。

针对幸存者s0,s1区的总结:复制之，后有交换，谁空谁是to
关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。


































